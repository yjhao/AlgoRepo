#303-C Woodcutters (贪心）
## 题意
有一排树， 没一个树都有自己的高度，可以锯掉或者保留。 如果锯掉的话， 可以往左边倒下或者右边倒下。 但是无论往哪边倒下， 都不能于左面或者右面的树重合，“左边或者右边的树” 可以是没有倒下的， 也可以是倒下的。 

问最多可以倒下多少个树。

##解题
首先可以判断的是， 第一个树肯定是往左倒下， 最后一个树肯定是往右倒下。

那么对于中间的树呢？

贪心的方法， 我们先假设某个树肯定是倒下的。 如果往左边倒下， 检查有没有重合， 如果左边不能倒下（有重合）， 那么就努力把这棵树往右边倒下。 然后更新在右边区域覆盖的位置。

如果是往左边倒下， 对后面的树木的倒下情况肯定是没有影响的， 我们只需要检查往左边倒下之后， 与之前倒下的最后一棵树木的位置有没有覆盖。

如果是往右边倒下， 只需要检查和右边的树的距离够不够。

如果是往右边倒下，最多可以影响到的树木就是在当前这颗树右边的这个树木： 有可能它就没有空间往左边倒下了。 但是它能不能往右边倒下， 跟当前的这棵树木没有任何关系。

最坏的情况： 这颗右边的树木不能往左倒下（它往右边倒下的距离也不够）， 但我们倒下了当前的这棵树， 所以总的“倒下的树木的”数量是没有变化的， 只是交换了一下顺序。

**每次倒下一棵树， 更新当前的最后被覆盖的位置**。 

##代码
```
public void solve() throws IOException {
        int n = in.nextInt();
        long[] x = new long[n];
        long[] h = new long[n];
        for (int i=0; i<n; i++){
            x[i] = in.nextLong();
            h[i] = in.nextLong();
        }
        
        int res = 0;
        if (n==2){
            out.print("2");
            return;
        }else if (n==1){
            out.print("1");
            return;
        }
        res = 2;

        long[] a = new long[n];
        int j = 0;
        a[0] = x[0];

        for (int i=1; i<n-1; i++){
            if (x[i]-x[i-1]>h[i] && x[i]-h[i]>a[j]){
                res ++;
                a[++j] = x[i];
            }else if (x[i+1]-x[i]>h[i]){
                res ++;
                a[++j] = x[i]+h[i];
            }
        }


        out.print(res);
    }
```