# 665-Non-decreasing Array

## 题意
给一个数组， 问能不能最多只改动一个数， 使得整个数组从左到右都是不递减的。

## 解题
我们从数组的最后往前扫描， 记录下来当前最后一个扫描的数的最大值， 那么在这之后扫描的数， 如果是小于等于这个数的话， 那么就满足条件， 否则的话， 就得在这里改动数字。 然后这样的改动不能超过一次。

关键核心点就是在于如何改动数字。

假设现在我们到I, 发现 i 并不是小于等于i+1的。 **那么我们现在有两种改动数字的方案**， 改变两个数中的任何一个， 都能满足局部的关系。

比如说 4 2 3, 4 2 5, or 4 2, 我们现在到了第一个4的位置。 

首先， 我们可以变小i， 使其等于i+1； 或者我们可以加大i+1， 使其等于i。任何两种中的一个都可以使得大小关系在这里得到满足。

我们可以greedy的去思考， 我们肯定是希望i越大越好，而不应该去减小I, 这样的话， 后面的数字的空间就会越多， 所以我们首选的是 变大I+1。 但是我们也不能肆无忌惮的变大I+1，因为有可能i+1变大之后， 就大于 i+2 了， 也是不满足的。

所以我们要确保要么没有 i+2， 或者 即使把I+1变大成I之后， 依然是小于等于 i+2 的话， 那么我们就可以不变小i， 而是变大 i+1， 从而使得大小关系在这里保持。

如果不满足这里的情况， 那么我们别无他法， 只有减小 i， 使其等于 i+1， 满足local的大小关系。 

## 代码
```
class Solution {
    public boolean checkPossibility(int[] nums) {
        if (nums.length<=2) return true;
        int pre = nums[nums.length-1];
        int cnt = 0;
        
        for (int i=nums.length-2; i>=0; i--){
            if (nums[i] <= pre){
                pre = nums[i];
                continue;
            }
            if (cnt==1) return false;
            cnt ++;
            if (i==nums.length-2 || nums[i+2] >= nums[i])   pre = nums[i];
        }
        
        return true;
    }
}
```