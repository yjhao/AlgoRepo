#307-Range Sum Query - Mutable (线段树， BIT）

## 题意
给一个array， 其中的值随时在变化， 在某一时刻， 求某段区域的和。

##解题——线段树
非常明显， 首先想到线段树。

线段树首先构造一个 节点数为 2 的完全次方的二叉树， 最低一层 放 array 的数字。 然后上面的节点存储的数据 分别是其 左右子孙包括的范围的 数据。 可以是最大最小值， 或者和。

**加和的时候**，先找到最底部的节点位置， 然后依次向上 track 并更新， idx = (idx-1)/2

**求某个区域 a-b 的和的时候**， 先从 root 出发， root 的节点位置为 0， 然后节点的数据涵盖的 范围 为 0 到 n-1， 标注为 l-r。 

如果 a-b 完全在 l-r 范围之外， 说明本节点及其子孙完全没有用， 直接返回0。 如果 l-r 完全被 a-b 所包括， 那么直接返回本节点的值， 因为l-r范围下的和已经被求到， 现在只需要求 a-l, r-b 的和。

如果不是这两种情况， 就一直往下 recursion 的找， 直到出现这两种情况。

往下找的时候， 更新 节点的位置， 和 节点的数据的涵盖范围。

```
左范围 l  ---   (l+r)/2,  右范围  (l+r)/2+1 --- r
``` 

##解题——BIT
通过线段树， 每一个节点的左右子孙 都被管理并更新了。 其实这是不需要的， 因为直到总的和 左孩子， 就一定知道 右孩子。

所以 BIT 可以应用在这里， BIT 比线段树更快。 但只能求和？

BIT 从 Index 1 开始， 用二进制表示。 以1结尾的1，3，5，7的长度是1， 以 10 结尾的 2，6的长度是2， 以 100 结尾的4的长度是3， 以1000结尾的8的长度是4。

BIT 的 求和 和 更新 使用的是位操作。

**更新中**， 我们加上当前 Index  的 最后一个 1 的位置。

```
while (i<=n){
    tree[i] += val;
    i += i&(-i);
}
```

如何 得到 最后一个1的位置？  i&(-i）。

-i 的二进制表示 就是 i 的 所有反码加一， 最后一个1的右边和左边由于是反码， 所以 & 下都为0。 在 最后一个1这个地方 1&（0+1） = 1。 这样就求出了 最后一个1的位置。

**更新的是差值**

**求和**

```
getSum(i,j) =  sum(i) - sum(j-1)
```

求 sum(i)， “从右往左” 依次累加, 加上最后一个 1 的位置。

```
while(i>0){
	res += tree[i];
    i -= i&(-i);
}
```

**注意细节**

1. BIT 是从1开始的。
2. 更新的是差值。
3. 需要有两个数组 nums 和 bit






