# 668 - Kth Smallest Number in Multiplication Table

## 题意
给一个长宽分别为 M N 的乘法表， 问在这其中， 第k大的数是多少。

## 解题

首先可以知道这个题目肯定是需要用二分来做。我们可以先猜一个数， 然后根据有多少数**小于等于**他， 来更新左右指针。

如果把乘法表变成一个Sorted array， 会类似于： 1 2 2 3 3 5 5 5 6 6 6， 可以转化为在这个数列中找第k大的数。

有几个细节需要注意：

1. 在每次比较中， 直觉好像是， 判断有多少数小于p， 然后如果这个答案小于k，往右移， 反之往左移。但实际上，有些数在乘法表中出现了多次， 所以**不能使用“有多少数<p”**， 

    1. 关键的论据：要得到第四大的数， 如果发现对于P， 有三个数小于它， 那么我们究竟该往左边还是右边移动呢？ 因为这些数是sparse的， 所以p的左右都可能出现答案。在这里的的关键就是， 要求到第k大的数， 我们就直接使用有多少数<=k， 而不应该间接的使用有多少个数<k。 如果这些数是连续的， 可以这样使用， 但因为数是sparse的， 所以从第二个论据推不到第一个论据， 所以我们使用直接的论据。

	
	2. 假设有2个数小于p，我们要求的是第4大的数， 晃眼一看， p肯定不会是第4大的数了，我们往右移，但这只在p有且只有一个的基础上是成立的， 假设p有3个， 那么p还是会成为第四大的数。所以使用 left= mid； 这样的话， 最后的base条件处理就很困难。
2. 有可能有些数不会出现在这个乘法表中， 所以如果发现有k个数小于等于p， 答案有可能不是p， 因为p有可能在这个表中不存在， 但是这个数一定不会大于p。 假设p1大于p，那么如果p1是答案的话， 小于等于p1的数一定会至少为k+1， 因为还要算上p1=p1的那一个。



综上所述， 我们在每次判断的时候， 要判断有多少数小于等于p， 


1. 如果这个结果是小于k的， 那么答案一定会比p大， 所以 left = p+1； 
2. 如果这个结果是等于k的， 那么显然答案有可能是p， 但不可能是比p大的数， 所以 right = p； 参照上面的例子。
3. 如果这个结果是大于k的，答案也有可能是p。 比如说1 2 2 2 2 3， 求第3大的数， 当访问到2的时候， 发现小于扥会于2的数有5个， 这是因为2自己占了太多的比重。所以因为答案有可能还是P, 所以更新的时候， 得使用 right = p；

在求有多少个数小于等于P的时候， 细节也很重要。 对于每一行， 我们分别求， 因为在这一行是个等差数列，首项我们知道， 所以用除法就知到最多有多少项是小于等于P的， 但是还需要注意， 总的列数， 也就是项数是有限的， 所以我们还要在这两个数之间去一个最小值。


## 代码
```
class Solution {
    public int findKthNumber(int m, int n, int k) {
        int l = 1;
        int r = m*n+1;
        
        while (l<r){
            int mid = l + (r-l)/2;
            int cnt = smallerOrEqualTo(m, n, mid);
            if (cnt<k)  l = mid+1;
            else r = mid;
        }
        return l;
    }
    
    int smallerOrEqualTo(int m, int n, int mid){
        int res = 0;
        for (int i=1; i<=m; i++){
            res += Math.min(mid/i, n);
        }
        return res;
    }
}
```

